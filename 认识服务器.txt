1.获取class对象
    用户访问服务器就是问了获取服务器内的资源和服务，而资源和服务是
通过访问地址决定的。服务器将不同的访问地址对应的资源提供给用户，而这
些资源就是（想象一下）每个class对象内的代码。这就要求动态获取类名，
动态生成对象，然后调用对象内部的方法。
    AClass A = new AClass();这个方法只能静态生成类A的实例。
    想要动态生成一个类就必须动态获取类名。
    获取类名的方法有三：
        AClass A =new AClass();
		Class clz = A.getClass();
		clz = AClass.class;
		clz = Class.forName("PacketName.AClass");
    在这个情况下，通过“包名.类名”获取类名是一个很好的方法。然后通过
AClass B = (AClass)clz.getConstructor().newInstance();可以
对AClass进行实例化。

2.为什么我们非得用“包名.类名”的方法来获取类名并且实例化？
    大家应该都多少知道一点.xml文件的存在。这个文件几乎在所有前端项
目或者后端项目中出现。这个文件的作用就在于将资源和类映射起来。
<?xml version="1.0" encoding="UTF-8"?>  
 <web-app>
 <servlet>
  <servlet-name>myclass</servlet-name>
  <servlet-class>AClass</servlet-class>
 </servlet>
 <servlet-mapping>
  <servlet-name>myclass</servlet-name>
  <url-pattern>/my</url-pattern> 
  <url-pattern>/m</url-pattern>
  <url-pattern>/myclass</url-pattern>
 </servlet-mapping>  
 </web-app>

    .xml的作用有点类似于Map，它能够提供一对一的映射。通过它，我们期望能够找到
<servlet-class>AClass</servlet-class>中的AClass。
    我一开始看到这的时候，就想：为什么要用着种方式来找AClass？为什么不干脆把这些类的名
称存到txt里，再用文件流来读？
    因为.xml文件能够让我们通过多个资源名称来找到这个唯一的类名称。资源名称就是
<url-pattern>...</url-pattern>中“...”的部分叫做资源名称。
    在www上，每一信息资源都有统一且唯一的地址，即统一资源定位符
    Uniform Resource Locator。
    exp(1)如:http://localhost:8080/m,由4部分组成：
    • 协议: http
    • 存放资源的主机域名:localhost
    • 端口号:8080
    • 资源文件名:m

    exp(2)如:http://localhost:8080/myclass,由4部分组成：
    • 协议: http
    • 存放资源的主机域名:localhost
    • 端口号:8080
    • 资源文件名:myclass
    
    作为服务器的搭建者，我们希望用户在访问不同的资源名时，服务器最终提供的都是AClass
这个类中的服务。此时，就需要一个多资源名对唯一类名的映射。一句话来说明就是：一个资源名
对应一个类名，一个类名可以通过多个资源名访问。而.xml就是用来提供一个公认的方法（也可以叫
做标准）来完成这个工作。

3.如何使用.xml呢？

（1）使用<servlet-mapping>...</servlet-mapping>中的
<url-pattern>...</url-pattern>来映射
<servlet-mapping>...</servlet-mapping>中的<servlet-name>myclass</servlet-name>。
exp:用/my、/m、/myclass来找到myclass。
（2）使用<servlet-mapping>...</servlet-mapping>中的
<servlet-name>myclass</servlet-name>找到<servlet>...</servlet>
中相同的<servlet-name>myclass</servlet-name>。
（3）使用<servlet>...</servlet>中的<servlet-name>myclass</servlet-name>
来映射<servlet>...</servlet>中的<servlet-class>AClass</servlet-class>。
exp:我们有一个.xml文件
<?xml version="1.0" encoding="UTF-8"?>  
 <web-app>
 <servlet>
  <servlet-name>myclassA</servlet-name>
  <servlet-class>AClass</servlet-class>
 </servlet>
 <servlet-mapping>
  <servlet-name>myclassA</servlet-name>
  <url-pattern>/myA</url-pattern> 
  <url-pattern>/mA</url-pattern>
  <url-pattern>/myclassA</url-pattern>
 </servlet-mapping>
  <servlet>
  <servlet-name>myclassB</servlet-name>
  <servlet-class>BClass</servlet-class>
 </servlet>
 <servlet-mapping>
  <servlet-name>myclassB</servlet-name>
  <url-pattern>/myB</url-pattern> 
  <url-pattern>/mB</url-pattern>
  <url-pattern>/myclassB</url-pattern>
 </servlet-mapping> 
 </web-app>
    我们要获得AClass。步骤为：1.服务器收到一个资源名，并且判断是否是/myA、/mA、
/myclassA中的任意一个。2.（如果是）找到这个资源名对应的servlet-name，在这里是
myclassA。3.用</servlet-mapping>中的myclassA找到拥有相同servlet-name的
<servlet>。4.在这个<servlet>中找到<servlet-class>。5.返回<servlet-class>
中的类名。

4.上代码！
public class XmlLearning {

	public static void main(String[] args) throws Exception {
		//解析.xml文件我们主要用到java中的SAX解析工厂。
		//1、获取解析工厂
		SAXParserFactory factory=SAXParserFactory.newInstance();
		//2、从解析工厂获取解析器
		SAXParser saxParser =factory.newSAXParser();
		//3、编写处理器
		//4、加载文档 Document 注册处理器
		MyHandler handler=new MyHandler();
		//5、解析,""中可以写绝对路径，但是我把文件都放在同一目录下，所以就直接用了
		saxParser.parse(Thread.currentThread().getContextClassLoader()
		.getResourceAsStream("web.xml")
		,handler);

        /*
         *这里使用Thread.currentThread().getContextClassLoader()
		 *.getResourceAsStream("web.xml")的
         *具体原因是WEB程序，发布到Tomcat里面运行之后首先是执行
         *Tomcat org.apache.catalina.startup.Bootstrap类，这时候的类加载器是
         *ClassLoader.getSystemClassLoader()。如果在后面的WEB程序里使用
         *class.getClassLoader()，可能会导致和当前线程所运行的类加载器不一致。
         *
         *简单来说，使用Thread.currentThread().getContextClassLoader()时为了在
         *获取静态资源的时候，能够使用当前线程的类加载器。不用这个也可以，但是具体使用的是哪
         *个类加载器是开发者需要考虑的问题，毕竟java是多线程的。在这里我就不赘述了，有兴趣
         *的朋友可以去查一查其他的方法（查完回来告诉我一下呗 0 0）。
         *
         *如果不布置到Tomcat上，只是单纯在eclipse上运行，其实这里是可以写成下面
         *这个样子的。
         *saxParser.parse("src\\web.xml", new MyHandler());
         *
         *为什么要是用.getResourceAsStream("web.xml")呢？是因为相对路径这个概念
         *在本地eclipse里用着还行，但是到了服务器上就容易出问题。对于一般的项目，
         *写了相对路径之后会从项目的根目录开始往下找，但是到了服务器上，项目的根目录
         *就可能是服务器的某个路径。所以在服务器上想用相对路径，最好是用ClassLoader类的
         *getResource(String name),getResourceAsStream(String name)等方法
         *
         *综上所述，我们这里就使用
         *Thread.currentThread().getContextClassLoader().getResource("")
         *来得到当前的classpath的绝对路径的URI表示法。
         *         
         */
    }

}
class MyHandler extends DefaultHandler{
	@Override
	public void startDocument() throws SAXException {
		System.out.println("开始解析文档");
	}
	
	@Override
	public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
		System.out.println("开始解析："+qName);
	}
	
	@Override
	public void characters(char[] ch, int start, int length) throws SAXException {
		String contents = new String(ch,start,length).trim();
		if(contents.length()>0) {
			System.out.println("内容为："+contents);			
		}else {
			System.out.println("内容为："+"空");		
		}
	}
	
	@Override
	public void endElement(String uri, String localName, String qName) throws SAXException {
		System.out.println("解析结束："+qName);
	}
	@Override
	public void endDocument() throws SAXException {
		System.out.println("解析文档结束");
	}
}
